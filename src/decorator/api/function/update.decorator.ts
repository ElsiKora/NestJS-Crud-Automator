import { HttpException, InternalServerErrorException } from "@nestjs/common";

import { EErrorStringAction } from "../../../enum";
import { ErrorException, ErrorString, GetEntityColumns } from "../../../utility";

import { ApiFunctionGet } from "./get.decorator";

import type { IApiBaseEntity } from "../../../interface";
import type { TApiFunctionGetProperties, TApiFunctionUpdateProperties } from "../../../type";

import type { DeepPartial, Repository } from "typeorm";

async function executor<E extends IApiBaseEntity>(repository: Repository<E>, entityType: new () => E, id: number | string, properties: TApiFunctionUpdateProperties<E>, getFunction: (id: string, properties?: TApiFunctionGetProperties<E>) => Promise<E>): Promise<E> {
	try {
		const entity: E = await getFunction(id.toString());

		const allColumns: Array<keyof E> = GetEntityColumns<E>({ entity: entityType, shouldTakeGeneratedOnly: false });
		const autoGeneratedColumns: Array<keyof E> = GetEntityColumns<E>({ entity: entityType, shouldTakeGeneratedOnly: true });

		const filteredProperties: DeepPartial<E> = Object.fromEntries(Object.entries(properties).filter(([key]: [string, unknown]) => allColumns.includes(key as keyof E) && !autoGeneratedColumns.includes(key as keyof E))) as DeepPartial<E>;

		const updatedEntity: E = repository.merge(entity, filteredProperties);

		return await repository.save(updatedEntity);
	} catch (error) {
		console.log(error);

		if (error instanceof HttpException) {
			throw error;
		}

		throw new InternalServerErrorException(
			ErrorString({
				entity: entityType,
				type: EErrorStringAction.UPDATING_ERROR,
			}),
		);
	}
}

export function ApiFunctionUpdate<E extends IApiBaseEntity>(options: { model: new () => E }) {
	// eslint-disable-next-line @typescript-eslint/naming-convention
	return function (_target: unknown, _propertyKey: string, descriptor: PropertyDescriptor): PropertyDescriptor {
		const getDecorator: (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor = ApiFunctionGet({ model: options.model });
		let getFunction: (id: string, properties?: TApiFunctionGetProperties<E>) => Promise<E>;

		descriptor.value = async function (
			this: {
				repository: Repository<E>;
			},
			id: number | string,
			properties: TApiFunctionUpdateProperties<InstanceType<typeof options.model>>,
		): Promise<E> {
			const repository: Repository<E> = this.repository;

			if (!repository) {
				throw ErrorException("Repository is not available in this context");
			}

			if (!getFunction) {
				const getDescriptor: TypedPropertyDescriptor<(id: string, properties?: TApiFunctionGetProperties<E>) => Promise<E>> = {
					value: function () {
						return Promise.reject(ErrorException("Not implemented"));
					},
				};
				getDecorator(this, "get", getDescriptor);

				if (getDescriptor.value) {
					getFunction = getDescriptor.value.bind(this);
				} else {
					throw ErrorException("Get function is not properly decorated");
				}
			}

			return executor<E>(repository, options.model, id, properties, getFunction);
		};

		return descriptor;
	};
}
