import {BaseEntity, DeepPartial, Repository} from "typeorm";
import {HttpException, InternalServerErrorException} from "@nestjs/common";
import {ErrorString, GetEntityColumns} from "../../../utility";
import {EErrorStringAction} from "../../../enum";
import {TApiFunctionGetProperties, TApiFunctionUpdateProperties} from "../../../type";
import {ApiFunctionGet} from "./get.decorator";

async function executor<E extends BaseEntity>(
    repository: Repository<E>,
    entityType: new () => E,
    id: string | number,
    properties: TApiFunctionUpdateProperties<E>,
    getFunction:(id: string, properties?: TApiFunctionGetProperties<E>) => Promise<E>
): Promise<E> {
    try {
        const entity = await getFunction(id.toString());

        const allColumns = GetEntityColumns(entityType);
        const autoGeneratedColumns = GetEntityColumns(entityType, true);

        const filteredProperties = Object.keys(properties).reduce((acc, key) => {
            if (allColumns.includes(key as keyof E) && !autoGeneratedColumns.includes(key as keyof E)) {
                (acc as any)[key] = (properties as any)[key];
            }
            return acc;
        }, {} as DeepPartial<E>);

        const updatedEntity = repository.merge(entity, filteredProperties);
        const savedEntity = await repository.save(updatedEntity);
        return savedEntity;
    } catch (error) {
        console.log(error);
        if (error instanceof HttpException) {
            throw error;
        }
        throw new InternalServerErrorException(
            ErrorString({
                entity: entityType,
                type: EErrorStringAction.UPDATING_ERROR,
            })
        );
    }
}

export function ApiFunctionUpdate<E extends BaseEntity>(options: { model: new () => E }) {
    return function (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) {
        const getDecorator = ApiFunctionGet({ model: options.model });
        let getFunction: (id: string, properties?: TApiFunctionGetProperties<E>) => Promise<E>;

        descriptor.value = async function (
            this: {
                repository: Repository<E>;
            },
            id: string | number,
            properties: TApiFunctionUpdateProperties<InstanceType<typeof options.model>>
        ) {
            const repository: Repository<E> = this.repository;
            if (!repository) {
                throw new Error("Repository is not available in this context");
            }

            if (!getFunction) {
                const getDescriptor: TypedPropertyDescriptor<(id: string, properties?: TApiFunctionGetProperties<E>) => Promise<E>> = {
                    value: function() { return Promise.reject(new Error('Not implemented')); }
                };
                getDecorator(this, 'get', getDescriptor);
                if (getDescriptor.value) {
                    getFunction = getDescriptor.value.bind(this);
                } else {
                    throw new Error('Get function is not properly decorated');
                }
            }

            return executor(repository, options.model, id, properties, getFunction);
        };

        return descriptor;
    };
}
