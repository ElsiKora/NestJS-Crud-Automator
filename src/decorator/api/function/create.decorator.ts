import { HttpException, InternalServerErrorException } from "@nestjs/common";

import { EErrorStringAction } from "../../../enum";

import { ErrorString } from "../../../utility";
import { GetEntityColumns } from "../../../utility/get-entity-columns.utility";

import type { TApiFunctionCreateProperties } from "../../../type";

import type { BaseEntity, DeepPartial, Repository } from "typeorm";

async function executor<E extends BaseEntity>(repository: Repository<E>, entityType: new () => E, properties: TApiFunctionCreateProperties<E>): Promise<E> {
	try {
		const allColumns = GetEntityColumns(entityType);
		const autoGeneratedColumns = GetEntityColumns(entityType, true);

		const filteredProperties = Object.keys(properties).reduce((accumulator, key) => {
			if (allColumns.includes(key as keyof E) && !autoGeneratedColumns.includes(key as keyof E)) {
				(accumulator as any)[key] = (properties as any)[key];
			}

			return accumulator;
		}, {} as DeepPartial<E>);

		const newEntity = repository.create(filteredProperties);

		return await repository.save(newEntity);
	} catch (error) {
		console.log(error);

		if (error instanceof HttpException) {
			throw error;
		}

		throw new InternalServerErrorException(
			ErrorString({
				entity: entityType,
				type: EErrorStringAction.CREATING_ERROR,
			}),
		);
	}
}

export function ApiFunctionCreate<E extends BaseEntity>(options: { model: new () => E }) {
	return function (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) {
		descriptor.value = async function (
			this: {
				repository: Repository<E>;
			},
			properties: TApiFunctionCreateProperties<InstanceType<typeof options.model>>,
		) {
			const repository: Repository<E> = this.repository;

			if (!repository) {
				throw new Error("Repository is not available in this context");
			}

			return executor(repository, options.model, properties);
		};

		return descriptor;
	};
}
