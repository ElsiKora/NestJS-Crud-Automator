{"version":3,"file":"has-paired-custom-suffixes-fields.validator.js","sourceRoot":"","sources":["has-paired-custom-suffixes-fields.validator.ts"],"names":[],"mappings":"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","sourcesContent":["import { type ValidationArguments, ValidatorConstraint, ValidatorConstraintInterface } from \"class-validator\";\n\nimport { EFilterOperation } from \"../enum/filter-operation.enum\";\n\nenum EArgumentType {\n\tARRAY = \"array\",\n\tNULL = \"null\",\n\tSINGLE = \"single\",\n}\n\ntype TOperationConfig = {\n\targumentType: EArgumentType;\n\texactLength?: number;\n\tmaxLength?: number;\n\tminLength?: number;\n};\n\ntype TValidationContext = {\n\t__fieldGroups: Map<string, Set<string>>;\n\t__operatorSuffix: string;\n\t__valueSuffixes: Array<string>;\n};\n\nconst DEFAULT_OPERATION_CONFIGS: Record<EFilterOperation, TOperationConfig> = {\n\t[EFilterOperation.BETWEEN]: {\n\t\targumentType: EArgumentType.ARRAY,\n\t\t// eslint-disable-next-line @elsikora/typescript/no-magic-numbers\n\t\texactLength: 2,\n\t},\n\t[EFilterOperation.CONT]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.CONTL]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.ENDS]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.ENDSL]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.EQ]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.EQL]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.EXCL]: {\n\t\targumentType: EArgumentType.ARRAY,\n\t},\n\t[EFilterOperation.EXCLL]: {\n\t\targumentType: EArgumentType.ARRAY,\n\t},\n\t[EFilterOperation.GT]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.GTE]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.IN]: {\n\t\targumentType: EArgumentType.ARRAY,\n\t\tminLength: 1,\n\t},\n\t[EFilterOperation.INL]: {\n\t\targumentType: EArgumentType.ARRAY,\n\t\tminLength: 1,\n\t},\n\t[EFilterOperation.ISNULL]: {\n\t\targumentType: EArgumentType.NULL,\n\t},\n\t[EFilterOperation.LT]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.LTE]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.NE]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.NEL]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.NOTIN]: {\n\t\targumentType: EArgumentType.ARRAY,\n\t\tminLength: 1,\n\t},\n\t[EFilterOperation.NOTINL]: {\n\t\targumentType: EArgumentType.ARRAY,\n\t\tminLength: 1,\n\t},\n\t[EFilterOperation.NOTNULL]: {\n\t\targumentType: EArgumentType.NULL,\n\t},\n\t[EFilterOperation.STARTS]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n\t[EFilterOperation.STARTSL]: {\n\t\targumentType: EArgumentType.SINGLE,\n\t},\n};\n\n// eslint-disable-next-line @elsikora/typescript/naming-convention\n@ValidatorConstraint({ async: false, name: \"has-paired-custom-suffixes-fields\" })\nexport class HasPairedCustomSuffixesFields implements ValidatorConstraintInterface {\n\tdefaultMessage(properties: ValidationArguments): string {\n\t\tconst object: TValidationContext = properties.object as TValidationContext;\n\t\tconst fieldGroups: Map<string, Set<string>> = object.__fieldGroups;\n\t\tconst operatorSuffix: string = object.__operatorSuffix;\n\t\tconst valueSuffixes: Array<string> = object.__valueSuffixes;\n\t\tconst indexableObject: Record<string, unknown> = properties.object as Record<string, unknown>;\n\n\t\tfor (const [baseName, groupSuffixes] of fieldGroups) {\n\t\t\tconst hasValueSuffix: boolean = valueSuffixes.some((suffix: string) => groupSuffixes.has(suffix));\n\n\t\t\tif (hasValueSuffix && !groupSuffixes.has(operatorSuffix)) {\n\t\t\t\treturn `group \"${baseName}\" with value suffix must have an operator suffix [${operatorSuffix}]`;\n\t\t\t}\n\n\t\t\tif (groupSuffixes.has(operatorSuffix)) {\n\t\t\t\tif (groupSuffixes.size === 1) {\n\t\t\t\t\treturn `group \"${baseName}\" with operator suffix must have at least one value with suffix [${[...valueSuffixes].join(\", \")}]`;\n\t\t\t\t}\n\n\t\t\t\tconst operatorField: string = `${baseName}[${operatorSuffix}]`;\n\t\t\t\tconst operatorValue: string = indexableObject[operatorField] as string;\n\t\t\t\tconst operator: EFilterOperation = operatorValue as EFilterOperation;\n\t\t\t\tconst operatorConfig: TOperationConfig = DEFAULT_OPERATION_CONFIGS[operator];\n\n\t\t\t\tif (!operatorConfig) {\n\t\t\t\t\treturn `Invalid operator \"${operator}\" for group \"${baseName}\"`;\n\t\t\t\t}\n\n\t\t\t\tif (operatorConfig.argumentType === EArgumentType.NULL) {\n\t\t\t\t\tconst valueCount: number = valueSuffixes.filter((suffix: string) => groupSuffixes.has(suffix)).length;\n\n\t\t\t\t\tif (valueCount > 0) {\n\t\t\t\t\t\treturn `group \"${baseName}\" with ${operator} operation should not have any values`;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst valueFields: Array<string> = valueSuffixes.filter((suffix: string) => groupSuffixes.has(suffix)).map((suffix: string) => `${baseName}[${suffix}]`);\n\n\t\t\t\tif (valueFields.length === 0) {\n\t\t\t\t\treturn `group \"${baseName}\" requires a value for ${operator} operation`;\n\t\t\t\t}\n\n\t\t\t\tif (valueFields.length > 1) {\n\t\t\t\t\treturn `group \"${baseName}\" can only have one value with suffix [${[...valueSuffixes].join(\", \")}] when operator is present`;\n\t\t\t\t}\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst value: Array<any> = indexableObject[valueFields[0]];\n\t\t\t\tconst isArray: boolean = Array.isArray(value);\n\n\t\t\t\tif (operatorConfig.argumentType === EArgumentType.ARRAY && !isArray) {\n\t\t\t\t\treturn `group \"${baseName}\" with ${operator} operation requires an array value`;\n\t\t\t\t}\n\n\t\t\t\tif (operatorConfig.argumentType === EArgumentType.SINGLE && isArray) {\n\t\t\t\t\treturn `group \"${baseName}\" with ${operator} operation requires a single value, not an array`;\n\t\t\t\t}\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tif (operatorConfig.exactLength !== undefined && value.length !== operatorConfig.exactLength) {\n\t\t\t\t\t\treturn `group \"${baseName}\" with ${operator} operation requires exactly ${String(operatorConfig.exactLength)} values`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (operatorConfig.minLength !== undefined && value.length < operatorConfig.minLength) {\n\t\t\t\t\t\treturn `group \"${baseName}\" with ${operator} operation requires at least ${String(operatorConfig.minLength)} values`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (operatorConfig.maxLength !== undefined && value.length > operatorConfig.maxLength) {\n\t\t\t\t\t\treturn `group \"${baseName}\" with ${operator} operation requires at most ${String(operatorConfig.maxLength)} values`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn `fields must have valid operator-value suffix pairs`;\n\t}\n\n\tvalidate(_value: unknown, properties: { constraints: [string, Array<string>] } & ValidationArguments): boolean {\n\t\tconst [operatorSuffix, valueSuffixes]: [string, Array<string>] = properties.constraints;\n\t\tconst indexableObject: Record<string, unknown> = properties.object as Record<string, unknown>;\n\t\tconst fields: Array<string> = Object.keys(indexableObject);\n\t\tconst fieldGroups: Map<string, Set<string>> = new Map<string, Set<string>>();\n\n\t\tconst suffixPattern: string = [operatorSuffix, ...valueSuffixes].map((suffix: string): string => suffix.replaceAll(/[.*+?^${}()|[\\]\\\\]/g, String.raw`\\$&`)).join(\"|\");\n\t\tconst regex: RegExp = new RegExp(`^(.+?)\\\\[(${suffixPattern})\\\\]$`);\n\n\t\tfor (const field of fields) {\n\t\t\tconst match: null | RegExpExecArray = regex.exec(field);\n\n\t\t\tif (match) {\n\t\t\t\tconst [, baseName, suffix]: [string, string, string] = match as unknown as [string, string, string];\n\n\t\t\t\tif (!fieldGroups.has(baseName)) {\n\t\t\t\t\tfieldGroups.set(baseName, new Set<string>());\n\t\t\t\t}\n\n\t\t\t\tif (indexableObject[field] !== undefined) {\n\t\t\t\t\tfieldGroups.get(baseName)?.add(suffix);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t(properties.object as TValidationContext).__fieldGroups = fieldGroups;\n\t\t(properties.object as TValidationContext).__operatorSuffix = operatorSuffix;\n\t\t(properties.object as TValidationContext).__valueSuffixes = valueSuffixes;\n\n\t\tfor (const [baseName, groupSuffixes] of fieldGroups) {\n\t\t\tconst hasValueSuffix: boolean = valueSuffixes.some((suffix: string) => groupSuffixes.has(suffix));\n\n\t\t\tif (hasValueSuffix && !groupSuffixes.has(operatorSuffix)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (groupSuffixes.has(operatorSuffix)) {\n\t\t\t\tconst operatorField: string = `${baseName}[${operatorSuffix}]`;\n\t\t\t\tconst operatorValue: string = indexableObject[operatorField] as string;\n\t\t\t\tconst operator: EFilterOperation = operatorValue as EFilterOperation;\n\t\t\t\tconst operatorConfig: TOperationConfig = DEFAULT_OPERATION_CONFIGS[operator];\n\n\t\t\t\tif (!operatorConfig) return false;\n\n\t\t\t\tif (operatorConfig.argumentType === EArgumentType.NULL) {\n\t\t\t\t\tconst valueCount: number = valueSuffixes.filter((suffix: string) => groupSuffixes.has(suffix)).length;\n\n\t\t\t\t\tif (valueCount > 0) return false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst valueFields: Array<string> = valueSuffixes.filter((suffix: string) => groupSuffixes.has(suffix)).map((suffix: string) => `${baseName}[${suffix}]`);\n\n\t\t\t\tif (valueFields.length !== 1) return false;\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tconst value: Array<any> = indexableObject[valueFields[0]];\n\t\t\t\tconst isArray: boolean = Array.isArray(value);\n\n\t\t\t\tif (operatorConfig.argumentType === EArgumentType.ARRAY && !isArray) return false;\n\n\t\t\t\tif (operatorConfig.argumentType === EArgumentType.SINGLE && isArray) return false;\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tif (operatorConfig.exactLength !== undefined && value.length !== operatorConfig.exactLength) return false;\n\n\t\t\t\t\tif (operatorConfig.minLength !== undefined && value.length < operatorConfig.minLength) return false;\n\n\t\t\t\t\tif (operatorConfig.maxLength !== undefined && value.length > operatorConfig.maxLength) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"]}